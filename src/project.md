homeworks (7 weeks): code up the unit tests

projects (7 weeks): 

(hey, this is a hard project. if you rty, and it all bombs afor you, then just
port my lua code to any of the languages listed in the  tiobe top 50
. to avoid plagerism, its onely one group per language
(so expect someone else to graph PYTHON before you). and check the language with
me first... some of these would be... probelmatic (e.g. SQL or C).

build a discssion environemtnwhere that ises automated soeftware to offer
isnights to the users

The most exciting phrase to hear in science, the one that heralds new discoveries, is not “Eureka” but “That’s funny...”
-- Isaac Asimov (1920–1992)

"the greatest value of a picture is when it forces us to notice 
what we never expected to see."
-- John Tukey (1915–2000) 

pretty pictures? maybe but also maybe not. pretty pictures that jgith imrotant semantic
differences need some knowledge of what is to be doplayed
not hello world, but "hello....  that's odd"

(*) note, if too hard then 

As to rest, we say representation, reason, presentation (of results), discuss, plan. Clearly connected but for pedagogical  purposes, do them all separately.

Core idea #1: representation: Policy vs mechanism
Build mechanisms that can implement sample policies
E.g. be able to recognize an algorithm as a product line with variable points
Offer those variable points as 
E.g. command line options
Defined your own sort with all options. Partial match etc.
E.g. some JSON describing system options
E.g. some domain specific shorthand language that compiles/interprets down to that JSON
E.g. sub-classes that specialize some high-level pattern
E.g. functions that specialize a higher-level function
E.g. a rule interpreter
Theory: patterns, functional programming, human cognitive theory (cognitive overload, people, need small chunks)
Unix philosophy: e..g design of operating systems









 Core idea #2:reasoning.  stochastic sampling. Don’t look at all, just enough
 E.g. random
 E.g. grammar-based fuzzing
 E.g. clustering then sampling  (drawing one sample per cluster)
 Case study: sort some small x% of a larger list to build an initial balanced binary tree
 Theory: clustering, (a little) probability
 Core idea #3: presentation: Summary the samples. 
 E.g. hierarchical clustering to recursively group similar things 
 (then only report one item per group)
 symbolic data mining (to generate a small tree)
 E.g. discretization  (simplify by focusing on interesting patterns with numeric ranges)
 Theory: explanation (so much of that.  human cognitive theory (cognitive overload, people, need small chunks) T and Assumptions ⇒Goal
 T and Assumptions does not go to no good
 Core idea #4: Discuss.  In some parsimonous way. stakeholders score the summaries. Find the holes
 E.g. consider human concerns. Find parts of the summaries that make people frown/smile the most
 All of requirements engineering. configurable .  Energy consumption. Accessability. Fairness
 If u dont give them a chance to score fairness, then frainess becomes a random variabnle
 Parsonimony: andre stuff
 Core idea #5: cluster and contrast
 Find the delta between things peplanning = ople like/don’t like. Report those as either plans for improvement or things to watch for (the rainy day scenario)
 Or learn how to confuse and conflate a discuss

