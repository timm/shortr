<!DOCTYPE html>

<html>
<head>
  <title>brknbad.lua</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>brknbad.lua</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-1">&#x00a7;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre>                                                                     

<span class="hljs-keyword">local</span> b4={}; <span class="hljs-keyword">for</span> k,_ <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(<span class="hljs-built_in">_ENV</span>) <span class="hljs-keyword">do</span> b4[k]=k <span class="hljs-keyword">end</span> 
<span class="hljs-keyword">local</span> the, help = {}, <span class="hljs-string">[[

lua brknbad.lua [OPTIONS]
(c) 2022, Tim Menzies, BSD-2-Clause
Divide things. Show deltas between things.

OPTIONS:
  -cohen     -c cohen                 = .35
  -far       -F how far to seek poles = .9
  -keep      -k items to keep         = 256
  -minItems  -m min items in a rang e = .5
  -p         -p euclidean coefficient = 2
  -some      -S sample size for rows  = 512

OPTIONS, other:
  -dump      -d stackdump on error    = false
  -file      -f data file             = ../etc/data/auto93.csv
  -help      -h show help             = false
  -rnd       -r round numbers         = %5.2f
  -seed      -s random number seed    = 10019
  -todo      -t start-up action       = nothing
  -n1        -n1 #repeated trials     = 20
  -n2        -n2 samples per trial    = 100
]]</span>

<span class="hljs-keyword">local</span> any,bestBin,bins,bins1,bootstrap,class,cosine,csv2egs,firsts,fmt,ish
<span class="hljs-keyword">local</span> last,many,map,new,o,ok,oo,optimize,per,pop,push,quintiles,r,rnd,rnds,scottKnot
<span class="hljs-keyword">local</span> selects,settings,shuffle,slots,smallfx,<span class="hljs-built_in">sort</span>,sum,thing,things,xplains
<span class="hljs-keyword">local</span> NUM,SYM,EGS,BIN,CLUSTER,XPLAIN,GO,NO</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-2">&#x00a7;</a>
              </div>
              <p>[[</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
## Conventions

### Data 

- First row of data are names that describe each column.
- Names ending with `-` <span class="hljs-keyword">or</span> `+` are dependent goals to be minimized <span class="hljs-keyword">or</span> maximized.
- Names ending with `!` are dependent classes.
- Dependent columns are `y` columns (the rest are independent `x` columns).
- Uppercase names are numeric (so the rest are symbolic).
- Names ending with `:`<span class="hljs-string">&#x27; are columns to be skipped.
- Data is read as rows,  and stored in a EGS instance.
- Within a EGS, row columns are summarized into NUM or SYM instances.

### Inference

- The rows within an EGS are recursive bi-clustered into CLUSTERs
  using random projections (Fastmap) and Aha&#x27;</span>s distance metric
  (that can process numbers <span class="hljs-keyword">and</span> symbols).
- Entropy-based discretization finds BINs that separates each pair of
  clusters.
- An XPLAIN tree runs the same clustering processing, but data is divided
  at level using the BIN that most separates the clusters.

### Coding

- No globals (so everything is `<span class="hljs-keyword">local</span>`).
- Code <span class="hljs-number">80</span> characters wide indent with two spaces.  
- Format to be <span class="hljs-built_in">read</span> a two-pages-per-page portrait pdf.
- Divide code into section <span class="hljs-keyword">and</span> subsection headings (e.g using figlet)
- Sections are less than <span class="hljs-number">120</span> <span class="hljs-built_in">lines</span> long (one column <span class="hljs-keyword">in</span> the pdf).
- No <span class="hljs-built_in">lines</span> containing only the word `<span class="hljs-keyword">end</span>` (unless marking the <span class="hljs-keyword">end</span> of a
  complex <span class="hljs-keyword">for</span> loop <span class="hljs-keyword">or</span> <span class="hljs-function"><span class="hljs-keyword">function</span>)</span>.
- Usually, <span class="hljs-keyword">if</span> an object contains a list of other objects, that sublist
  is called `all`.
- If a slot is too big to display, it is declared private (<span class="hljs-keyword">not</span> to be printed)
  by renaming (e.g.) `slotx` to `_slotx` (so often, `all` becomes `_all`).

### Classes

- Spread class code across different sections (so don<span class="hljs-string">&#x27;t overload reader
  with all details, at one time).
- Show simpler stuff before complex stuff.
- Reserve `i` for `self` (to fit more code per line). 
- Don&#x27;</span>t use inheritance (to simplify readability). 
- Use polymorphism (using LUA<span class="hljs-string">&#x27;s  delegation trick).    
- Define an class of objects with `Thing=class&quot;thing&quot;` and 
  a `function:Thing(args)` creation method.
- Define instances with `new({slot1=value1,slot2=value2,...},Thing)`.
- Instance methods use `.`; e.g. `function Thing.show(i) ... end`.
- Class methods using `:`; e.g.  `Thing:new4strings`. Class methods
  do things like instance creation or manage a set of instances.

### Test suites (and demos)

- Define start-up actions as GO functions.  
- In GO functions, check for errors with `ok(test,mdf)` 
  (that updates an `fails` counter when not `ok`).
- Define another table called NO so a test can be quickly disabled just 
  by renaming it from `GO.xx` to `NO.xx`.

### At top of file 

- Trap known globals in `b4`.
- Define all locals at top-of-file (so everyone can access everything).
- Define options in a help string at top of file.
- Define command line options -h (for help); -s (for seeding random numbers)
 `-t` (for startup actions, so `-t all` means &quot;run everything&quot;).

### At end of file

- Using `settings`, parse help string to set options,
  maybe updating from command-line.
- Using `GO.main`, run the actions listed on command line.
- `GO.main`  resets random number generator before running an action 
- After everything else, look for `rogues` (any global not in `b4`)
- Finally, return the `fails` as the exit status of this code. --]]
                 

r=math.random
function ish(x,y,z)    return math.abs(y -x ) &lt; z end 
function cosine(a,b,c) 
  return math.max(0,math.min(1, (a^2+c^2-b^2)/(2*c+1E-32))) end


function any(a)        return a[ math.random(#a) ] end
function firsts(a,b)   return a[1] &lt; b[1] end
function last(a)       return a[ #a ] end
function many(a,n,  u) u={}; for j=1,n do push(u,any(a)) end; return u end
function map(t,f, u)   u={};for _,v in pairs(t) do push(u,f(v)) end;return u end
function per(a,p)      return a[ (p*#a)//1 ] end
function pop(a)        return table.remove(a) end
function push(t,x)     t[1 + #t] = x; return x end
function sort(t,f)     table.sort(t,f); return t end
function sum(t,f, n) 
  f = f or function(x) return x end
  n=0; for _,v in pairs(t) do n = n + f(v) end; return n end

function shuffle(t,   j)
  for i=#t,2,-1 do j=math.random(i); t[i],t[j]=t[j],t[i] end; return t end

local function quicksort(t,f,lo,hi)
  f= f or function(a,b) return a &lt;= b end
  lo, hi = lo or 1, hi or #t
  if (hi - lo &lt; 1) then return t end
  local j = lo
  for i = lo + 1, hi do
    if f(t[i],t[j]) then
      if   i == j + 1 
      then t[j],t[j+1]      = t[j+1],t[j]
      else t[j],t[j+1],t[i] = t[i],t[j],t[j+1] end
    j = j + 1 end 
  end
  t = quicksort(t, f, lo, j - 1)
  return quicksort(t, f, j + 1, hi) end


function thing(x)
  x = x:match&quot;^%s*(.-)%s*$&quot;
  if x==&quot;true&quot; then return true elseif x==&quot;false&quot; then return false end
  return tonumber(x) or x end

function things(file,      x)
  local function cells(x,  t)
    t={}; for y in x:gmatch(&quot;([^,]+)&quot;) do push(t, thing(y)) end; return t end
  file = io.input(file)
  return function()
    x=io.read(); if x then return cells(x) else io.close(file) end end end


fmt = string.format

function oo(t) print(o(t)) end

function o(t,  seen, u)  
  if type(t)~=&quot;table&quot; then return tostring(t) end
  seen = seen or {}
  if seen[t] then return &quot;...&quot; end
  seen[t] = t
  local function show1(x) return o(x, seen) end
  local function show2(k) return fmt(&quot;:%s %s&quot;,k,o(t[k],seen)) end
  u = #t&gt;0 and map(t,show1) or map(slots(t),show2)
  return (t._is or &quot;&quot;)..&quot;{&quot;..table.concat(u,&quot; &quot;)..&quot;}&quot; end

function slots(t, u)
  u={};for k,v in pairs(t) do if tostring(k):sub(1,1)~=&quot;_&quot; then push(u,k)end end
  return sort(u) end

function rnds(t,f) return map(t, function(x) return rnd(x,f) end) end
function rnd(x,f) 
  return fmt(type(x)==&quot;number&quot; and (x~=x//1 and f or the.rnd) or &quot;%s&quot;,x) end


function settings(help,    d)
  d={}
  help:gsub(&quot;\n  ([-]([^%s]+))[%s]+(-[^%s]+)[^\n]*%s([^%s]+)&quot;,
    function(long,key,short,x)
      for n,flag in ipairs(arg) do 
        if flag==short or flag==long then
          x = x==&quot;false&quot; and true or x==&quot;true&quot; and &quot;false&quot; or arg[n+1] end end 
       d[key] = x==true and true or thing(x) end)
  if d.help then print(help) end
  return d end

                 
GO, NO = {fails=0}, {}
function ok(test,msg)
  print(test and &quot;      PASS: &quot;or &quot;      FAIL: &quot;,msg or &quot;&quot;) 
  if not test then 
    GO.fails = GO.fails+1 
    if the.dump then assert(test,msg) end end end

function GO.main(todo,seed)
  for k,one in pairs(todo==&quot;all&quot; and slots(GO) or {todo}) do
    if k ~= &quot;main&quot; and type(GO[one]) == &quot;function&quot; then
      math.randomseed(seed)
      print(fmt(&quot;:%s&quot;,one))
      GO[one]() end end 
  for k,v in pairs(_ENV) do if not b4[k] then print(&quot;?&quot;,k,type(v)) end end  end


new = setmetatable
function class(s,   t)
  t={__tostring=o,_is=s or &quot;&quot;}; t.__index=t
  return new(t, {__call=function(_,...) return t.new(_,...) end}) end
                                
NUM, SYM, EGS = class&quot;NUM&quot;, class&quot;SYM&quot;, class&quot;EGS&quot;


function SYM:new(at,name) 
    return new({at=at, name=name, most=0,n=0,all={}}, SYM) end

function NUM:new(at,name) 
    return new({at=at, name=name, _all={}, 
                w=(name or &quot;&quot;):find&quot;-$&quot; and -1 or 1,
                n=0, sd=0, mu=0, m2=0, lo=math.huge, hi=-math.huge}, NUM) end

function EGS:new(names,  i,col)
  i = new({_all={}, cols={names=names, all={}, x={}, y={}}}, EGS)
  for at,name in pairs(names) do
    col = push(i.cols.all, (name:find&quot;^[A-Z]&quot; and NUM or SYM)(at,name) )
    if not name:find&quot;:$&quot; then
      if name:find&quot;!$&quot; then i.cols.class = col end 
      push(name:find&quot;[-+!]$&quot; and i.cols.y or i.cols.x, col) end end
  return i end

function EGS:new4file(file,  i)
  for row in things(the.file) do 
    if i then i:add(row) else i = EGS(row) end end 
  return i end


function SYM.copy(i) return SYM(i.at, i.name) end

function NUM.copy(i) return NUM(i.at, i.name) end

function EGS.copy(i,rows,    j) 
  j = EGS(i.cols.names)
  for _,row in pairs(rows or {}) do j:add(row) end 
  return j end


function EGS.add(i,row)
  push(i._all,  row)
  for at,col in pairs(i.cols.all) do col:add(row[col.at]) end end 

function SYM.add(i,x,inc)
  if x ~= &quot;?&quot; then
    inc = inc or 1
    i.n = i.n+inc
    i.all[x] = inc + (i.all[x] or 0)
    if i.all[x] &gt; i.most then i.most, i.mode = i.all[x], x end end end

function SYM.sub(i,x,inc)
  if x ~= &quot;?&quot; then
    inc = inc or 1
    i.n = i.n - inc
    i.all[x] = i.all[x] - inc end end

function NUM.add(i,x,_,    d,a)
  if x ~=&quot;?&quot; then
    i.n   = i.n + 1
    d     = x - i.mu
    i.mu  = i.mu + d/i.n
    i.m2  = i.m2 + d*(x - i.mu)
    i.sd  = (i.m2&lt;0 or i.n&lt;2) and 0 or ((i.m2/(i.n - 1))^0.5)
    i.lo  = math.min(x, i.lo)
    i.hi  = math.max(x, i.hi) 
    a     = i._all
    if     #a  &lt; the.keep     then i.ok=false; push(a,x)  
    elseif r() &lt; the.keep/i.n then i.ok=false; a[r(#a)]=x end end end

function NUM.sub(i,x,_,    d)
  if x ~=&quot;?&quot; then
    i.n   = i.n - 1
    d     = x - i.mu
    i.mu  = i.mu - d/i.n
    i.m2  = i.m2 - d*(x - i.mu)
    i.sd  = (i.m2&lt;0 or i.n&lt;2) and 0 or ((i.m2/(i.n - 1))^0.5) end end

  
function EGS.mid(i,cols)
  return map(cols or i.cols.y, function(col) return col:mid() end) end

function EGS.div(i,cols)
  return map(cols or i.cols.y, function(col) return col:div() end) end

function NUM.mid(i) return i.mu end
function SYM.mid(i) return i.mode end

function NUM.div(i) return i.sd end
function SYM.div(i,  e)
  e=0; for _,n in pairs(i.all) do
         if n &gt; 0 then e = e - n/i.n * math.log(n/i.n,2) end end
  return math.abs(e) end

function NUM.norm(i,x)
  return i.hi - i.lo &lt; 1E-32 and 0 or (x - i.lo)/(i.hi - i.lo) end 

function NUM.all(i)
  if not i.ok then table.sort(i._all); i.ok=true end
  return i._all end

</span></pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-3">&#x00a7;</a>
              </div>
              <p>   $ lua brknbad.lua -t cluster</p>
<p>   398
   | 199
   | | 99               Weight- Acc+  Mpg+
   | | | 49             ======= ===== =====
   | | | | 24          {2542.50 15.68 26.25}
   | | | | 25          {2408.48 17.72 35.20}
   | | | 50
   | | | | 25          {2432.12 16.04 28.80}
   | | | | 25          {2504.20 16.52 30.80}
   | | 100
   | | | 50
   | | | | 25          {2189.64 16.25 34.00} &lt;== best
   | | | | 25          {2261.56 16.24 28.80}
   | | | 50
   | | | | 25          {2309.24 16.74 26.00}
   | | | | 25          {2194.60 16.10 26.00}
   | 199
   | | 99
   | | | 49
   | | | | 24          {3959.83 13.06 14.17}
   | | | | 25          {4257.64 11.28 12.00} &lt;== worst
   | | | 50
   | | | | 25          {3940.24 13.84 19.60}
   | | | | 25          {4375.32 12.84 13.20} 
   | | 100
   | | | 50
   | | | | 25          {3220.32 17.40 21.20}
   | | | | 25          {3259.04 16.39 22.00}
   | | | 50
   | | | | 25          {3189.96 16.32 20.00}
   | | | | 25          {2504.56 16.56 23.20}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
CLUSTER=class<span class="hljs-string">&quot;CLUSTER&quot;</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CLUSTER:new</span><span class="hljs-params">(top,egs,      i,lefts,rights)</span></span>
  egs = egs <span class="hljs-keyword">or</span> top
  i   = new({egs=egs, top=top,rank=<span class="hljs-number">0</span>},CLUSTER)
  lefts, rights, i.left, i.right, i.border, i.c = top:half(egs._all)
  <span class="hljs-keyword">if</span> #egs._all &gt;= <span class="hljs-number">2</span>*(#top._all)^the.minItems <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">if</span> #lefts._all &lt; #egs._all <span class="hljs-keyword">then</span>
      i.lefts = CLUSTER(top, lefts)
      i.rights= CLUSTER(top, rights) <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">return</span> i <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CLUSTER.leaf</span><span class="hljs-params">(i)</span></span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> (i.lefts <span class="hljs-keyword">or</span> i.rights) <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CLUSTER.show</span><span class="hljs-params">(i,   pre, front)</span></span>
  pre = pre <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;&quot;</span>
  <span class="hljs-keyword">local</span> front = fmt(<span class="hljs-string">&quot;%s%s&quot;</span>,pre,#i.egs._all)
  <span class="hljs-keyword">if</span>   i:leaf() 
  <span class="hljs-keyword">then</span> <span class="hljs-built_in">print</span>(fmt(<span class="hljs-string">&quot;%-20s%s&quot;</span>,front, o(rnds(i.egs:mid(i.egs.cols.y)))))
  <span class="hljs-keyword">else</span> <span class="hljs-built_in">print</span>(front)
       <span class="hljs-keyword">if</span> i.lefts  <span class="hljs-keyword">then</span> i.lefts:show( <span class="hljs-string">&quot;| &quot;</span>..pre)
       <span class="hljs-keyword">if</span> i.rights <span class="hljs-keyword">then</span> i.rights:show(<span class="hljs-string">&quot;| &quot;</span>..pre) <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">EGS.half</span><span class="hljs-params">(i, rows)</span></span>
  <span class="hljs-keyword">local</span> project,far,some,left,right,c,lefts,rights,border
  rows    = rows <span class="hljs-keyword">or</span> i._all
  far     = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(r,t)</span></span>  <span class="hljs-keyword">return</span> per(i:dists(r,t), the.far)[<span class="hljs-number">2</span>] <span class="hljs-keyword">end</span>
  project = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(r1)</span></span> 
              <span class="hljs-keyword">return</span> {cosine(i:dist(left,r1), i:dist(right,r1), c),r1} <span class="hljs-keyword">end</span>
  some    = many(rows,       the.some)
  left    = far(any(some), some)
  right   = far(left,      some)
  c       = i:dist(left,right)
  lefts,rights = i:copy(), i:copy()
  <span class="hljs-keyword">for</span> n, projection <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(<span class="hljs-built_in">sort</span>(map(rows,project),firsts)) <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">if</span> n==#rows//<span class="hljs-number">2</span> <span class="hljs-keyword">then</span> border = projection[<span class="hljs-number">1</span>] <span class="hljs-keyword">end</span>
    (n &lt;= #rows//<span class="hljs-number">2</span> <span class="hljs-keyword">and</span> lefts <span class="hljs-keyword">or</span> rights):add( projection[<span class="hljs-number">2</span>] ) <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">return</span> lefts, rights, left, right, border, c  <span class="hljs-keyword">end</span>

                                          
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">EGS.dists</span><span class="hljs-params">(i,r1,rows)</span></span>
   <span class="hljs-keyword">return</span> <span class="hljs-built_in">sort</span>(map(rows,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(r2)</span></span> <span class="hljs-keyword">return</span> {i:dist(r1,r2),r2} <span class="hljs-keyword">end</span>),firsts) <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">EGS.dist</span><span class="hljs-params">(i,row1,row2,    d)</span></span>
  d = sum(i.cols.x, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(c)</span></span> <span class="hljs-keyword">return</span> c:dist(row1[c.at], row2[c.at])^the.p <span class="hljs-keyword">end</span>)
  <span class="hljs-keyword">return</span> (d/#i.cols.x)^(<span class="hljs-number">1</span>/the.p) <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NUM.dist</span><span class="hljs-params">(i,a,b)</span></span>
  <span class="hljs-keyword">if</span>     a==<span class="hljs-string">&quot;?&quot;</span> <span class="hljs-keyword">and</span> b==<span class="hljs-string">&quot;?&quot;</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">if</span>     a==<span class="hljs-string">&quot;?&quot;</span> <span class="hljs-keyword">then</span> b=i:norm(b); a=b&lt;<span class="hljs-number">.5</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> <span class="hljs-number">0</span> 
  <span class="hljs-keyword">elseif</span> b==<span class="hljs-string">&quot;?&quot;</span> <span class="hljs-keyword">then</span> a=i:norm(a); b=a&lt;<span class="hljs-number">.5</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>
  <span class="hljs-keyword">else</span>   a,b = i:norm(a), i:norm(b)  <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">math</span>.<span class="hljs-built_in">abs</span>(a - b) <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SYM.dist</span><span class="hljs-params">(i,a,b)</span></span> <span class="hljs-keyword">return</span> a==<span class="hljs-string">&quot;?&quot;</span> <span class="hljs-keyword">and</span> b==<span class="hljs-string">&quot;?&quot;</span> <span class="hljs-keyword">and</span> <span class="hljs-number">1</span> <span class="hljs-keyword">or</span> a==b <span class="hljs-keyword">and</span> <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> <span class="hljs-number">1</span> <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-4">&#x00a7;</a>
              </div>
              <pre><code>$ lua brknbad.lua -t bins

                     selects  diversity
                     =======  ========
      Clndrs   &lt; <span class="hljs-number">5</span>       <span class="hljs-number">211</span>   <span class="hljs-number">0.48</span>  
      Clndrs  &gt;= <span class="hljs-number">5</span>       <span class="hljs-number">187</span>   <span class="hljs-number">0.30</span>   &lt;== best overall

       Volume  &lt; <span class="hljs-number">121</span>     <span class="hljs-number">158</span>   <span class="hljs-number">0.23</span>
</code></pre>
<p>   121  &lt;= Volume  &lt; 168      63   0.84
   168  &lt;= Volume  &lt; 225      32   0.20
           Volume &gt;= 225     145   0.00   &lt;== pretty good</p>
<pre><code>       Model   &lt; <span class="hljs-number">73</span>      <span class="hljs-number">125</span>   <span class="hljs-number">0.87</span>
</code></pre>
<p>   73   &lt;= Model   &lt; 76       91   0.97
   76   &lt;= Model   &lt; 79       93   1.00
   Model &gt;= 79                89   0.47</p>
<pre><code>      origin == <span class="hljs-number">1</span>        <span class="hljs-number">249</span>   <span class="hljs-number">0.72</span>   &lt;== pretty bad
      origin == <span class="hljs-number">2</span>         <span class="hljs-number">70</span>   <span class="hljs-number">0.00</span>
      origin == <span class="hljs-number">3</span>         <span class="hljs-number">79</span>   <span class="hljs-number">0.00</span>
</code></pre>

            </div>
            
            <div class="content"><div class='highlight'><pre>
BIN=class<span class="hljs-string">&quot;BIN&quot;</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BIN:new</span><span class="hljs-params">(col,lo,hi,n,div)</span></span>
  <span class="hljs-keyword">return</span> new({col=col, lo=lo, hi=hi, n=n, div=div},BIN) <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BIN.selects</span><span class="hljs-params">(i,row,  x)</span></span>
  x = row[i.col.at]
  <span class="hljs-keyword">return</span> x==<span class="hljs-string">&quot;?&quot;</span> <span class="hljs-keyword">or</span> i.lo==i.hi <span class="hljs-keyword">and</span> x==i.lo <span class="hljs-keyword">or</span> i.lo&lt;=x <span class="hljs-keyword">and</span> x&lt;i.hi <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BIN.show</span><span class="hljs-params">(i,negative)</span></span>
  <span class="hljs-keyword">local</span> x, lo,hi,big, s = i.col.name, i.lo, i.hi, <span class="hljs-built_in">math</span>.<span class="hljs-built_in">huge</span>
  <span class="hljs-keyword">if</span> negative <span class="hljs-keyword">then</span>
    <span class="hljs-keyword">if</span>     lo== hi  <span class="hljs-keyword">then</span> s=fmt(<span class="hljs-string">&quot;%s != %s&quot;</span>,x,lo)  
    <span class="hljs-keyword">elseif</span> hi== big <span class="hljs-keyword">then</span> s=fmt(<span class="hljs-string">&quot;%s &lt;  %s&quot;</span>,x,lo) 
    <span class="hljs-keyword">elseif</span> lo==-big <span class="hljs-keyword">then</span> s=fmt(<span class="hljs-string">&quot;%s &gt;= %s&quot;</span>,x,hi)  
    <span class="hljs-keyword">else</span>                 s=fmt(<span class="hljs-string">&quot;%s &lt; %s and %s &gt;= %s&quot;</span>,x,lo,x,hi) <span class="hljs-keyword">end</span> 
  <span class="hljs-keyword">else</span>
    <span class="hljs-keyword">if</span>     lo== hi  <span class="hljs-keyword">then</span> s=fmt(<span class="hljs-string">&quot;%s == %s&quot;</span>,x,lo)  
    <span class="hljs-keyword">elseif</span> hi== big <span class="hljs-keyword">then</span> s=fmt(<span class="hljs-string">&quot;%s &gt;= %s&quot;</span>,x,lo)  
    <span class="hljs-keyword">elseif</span> lo==-big <span class="hljs-keyword">then</span> s=fmt(<span class="hljs-string">&quot;%s &lt;  %s&quot;</span>,x,hi)  
    <span class="hljs-keyword">else</span>                 s=fmt(<span class="hljs-string">&quot;%s &lt;= %s &lt; %s&quot;</span>,lo,x,hi) <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">return</span> s <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BIN.distance2heaven</span><span class="hljs-params">(i, divs, ns)</span></span>
  <span class="hljs-keyword">return</span> ((<span class="hljs-number">1</span> - ns:norm(i.n))^<span class="hljs-number">2</span> + (<span class="hljs-number">0</span> - divs:norm(i.div))^<span class="hljs-number">2</span>)^<span class="hljs-number">0.5</span> <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BIN:best</span><span class="hljs-params">(bins)</span></span>  
  <span class="hljs-keyword">local</span> divs,ns, distance2heaven = NUM(), NUM()
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">distance2heaven</span><span class="hljs-params">(bin)</span></span> <span class="hljs-keyword">return</span> {bin:distance2heaven(divs,ns),bin} <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">for</span> _,bin <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(bins) <span class="hljs-keyword">do</span> 
    divs:add(bin.div); ns:add(  bin.n) 
  <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">sort</span>(map(bins, distance2heaven), firsts)[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>]  <span class="hljs-keyword">end</span> 

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">EGS.bins</span><span class="hljs-params">(i,j,  bins)</span></span>
  bins = {}
  <span class="hljs-keyword">for</span> n,col <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(i.cols.x) <span class="hljs-keyword">do</span> 
    <span class="hljs-keyword">for</span> _,bin <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(col:bins(j.cols.x[n])) <span class="hljs-keyword">do</span> push(bins, bin) <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span> 
  <span class="hljs-keyword">return</span> bins <span class="hljs-keyword">end</span>


<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SYM.bins</span><span class="hljs-params">(i,j)</span></span>
  <span class="hljs-keyword">local</span> xys= {}
  <span class="hljs-keyword">for</span> x,n <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(i.all) <span class="hljs-keyword">do</span> push(xys, {x=x,y=<span class="hljs-string">&quot;left&quot;</span>, n=n}) <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">for</span> x,n <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(j.all) <span class="hljs-keyword">do</span> push(xys, {x=x,y=<span class="hljs-string">&quot;right&quot;</span>,n=n}) <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">return</span> BIN:new4SYMs(i, SYM, xys) <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BIN:new4SYMs</span><span class="hljs-params">(col, yclass, xys)</span></span> 
  <span class="hljs-keyword">local</span> out,all={}, {}
  <span class="hljs-keyword">for</span> _,xy <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(xys) <span class="hljs-keyword">do</span>
     all[xy.x] = all[xy.x] <span class="hljs-keyword">or</span> yclass()
     all[xy.x]:add(xy.y, xy.n)  <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">for</span> x,one <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(all) <span class="hljs-keyword">do</span> push(out,BIN(col, x, x, one.n, one:div())) <span class="hljs-keyword">end</span> 
  <span class="hljs-keyword">return</span> out <span class="hljs-keyword">end</span>

                                     
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">NUM.bins</span><span class="hljs-params">(i,j)</span></span>
  <span class="hljs-keyword">local</span> xys, all = {}, NUM()
  <span class="hljs-keyword">for</span> _,n <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(i._all) <span class="hljs-keyword">do</span> all:add(n); push(xys,{x=n,y=<span class="hljs-string">&quot;left&quot;</span>}) <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">for</span> _,n <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(j._all) <span class="hljs-keyword">do</span> all:add(n); push(xys,{x=n,y=<span class="hljs-string">&quot;right&quot;</span>}) <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">return</span> BIN:new4NUMs(i, SYM, <span class="hljs-built_in">sort</span>(xys,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a,b)</span></span> <span class="hljs-keyword">return</span> a.x &lt; b.x <span class="hljs-keyword">end</span>), 
                      (#xys)^the.minItems, all.sd*the.cohen) <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">BIN:new4NUMs</span><span class="hljs-params">(col, yclass, xys, minItems, cohen)</span></span>
  <span class="hljs-keyword">local</span> out, b4, argmin = {}, -<span class="hljs-built_in">math</span>.<span class="hljs-built_in">huge</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">argmin</span><span class="hljs-params">(lo,hi)</span></span>
    <span class="hljs-keyword">local</span> lhs, rhs, cut, div, xpect, xy = yclass(), yclass()
    <span class="hljs-keyword">for</span> j=lo,hi <span class="hljs-keyword">do</span>  rhs:add(xys[j].y) <span class="hljs-keyword">end</span>
    div = rhs:div()
    <span class="hljs-keyword">if</span> hi-lo+<span class="hljs-number">1</span> &gt; <span class="hljs-number">2</span>*minItems 
    <span class="hljs-keyword">then</span>
      <span class="hljs-keyword">for</span> j=lo,hi - minItems <span class="hljs-keyword">do</span>
        lhs:add(xys[j].y)
        rhs:<span class="hljs-built_in">sub</span>(xys[j].y)
        <span class="hljs-keyword">if</span>   lhs.n     &gt; minItems <span class="hljs-keyword">and</span>          <span class="hljs-comment">-- enough items (on left)</span>
             xys[j].x ~= xys[j+<span class="hljs-number">1</span>].x <span class="hljs-keyword">and</span>        <span class="hljs-comment">-- there is a break here</span>
             xys[j].x  - xys[lo].x &gt; cohen <span class="hljs-keyword">and</span> <span class="hljs-comment">-- not trivially small (on left) </span>
             xys[hi].x - xys[j].x  &gt; cohen     <span class="hljs-comment">-- not trivially small (on right)</span>
        <span class="hljs-keyword">then</span> xpect = (lhs.n*lhs:div() + rhs.n*rhs:div()) / (lhs.n+rhs.n) 
             <span class="hljs-keyword">if</span> xpect &lt; div <span class="hljs-keyword">then</span>               <span class="hljs-comment">-- cutting here simplifies things</span>
               cut, div = j, xpect <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span> <span class="hljs-comment">--end for</span>
    <span class="hljs-keyword">end</span> <span class="hljs-comment">-- end if</span>
    <span class="hljs-keyword">if</span>   cut 
    <span class="hljs-keyword">then</span> argmin(lo,    cut)
         argmin(cut+<span class="hljs-number">1</span>, hi )
    <span class="hljs-keyword">else</span> b4 = push(out, BIN(col, b4, xys[hi].x, hi-lo+<span class="hljs-number">1</span>, div)).hi <span class="hljs-keyword">end</span>
  argmin(<span class="hljs-number">1</span>,#xys)
  out[#out].hi =  <span class="hljs-built_in">math</span>.<span class="hljs-built_in">huge</span> 
  <span class="hljs-keyword">return</span> out <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-5">&#x00a7;</a>
              </div>
              <p>   % lua brknbad.lua -r xplain</p>
<pre><code>                                  Weight- Acc+  Mpg+
                                  ======= ===== =====
</code></pre>
<p>   398
   | Clndrs &gt;= 5 : 190
   | | Model &lt;  73 : 50
   | | | Volume &gt;= 318 : 29          {4213.93 11.52 12.41}
   | | | Volume &lt;  318 : 21          {3412.71 14.38 18.10}
   | | Model &gt;= 73 : 140
   | | | Model &gt;= 78 : 50            {3354.20 15.68 22.40}
   | | | | Volume &gt;= 225 : 32        {3554.53 15.69 20.94}
   | | | Model &lt;  78 : 90
   | | | | Volume &lt;  262 : 43        {3298.33 16.97 20.00}
   | | | | | Model &gt;= 75 : 28        {3401.82 17.36 20.00}
   | | | | Volume &gt;= 262 : 47
   | | | | | Model &lt;  74 : 20        {4279.05 12.25 12.00} &lt;== worst
   | | | | | Model &gt;= 74 : 27        {4177.30 13.40 15.93}
   | Clndrs &lt;  5 : 208
   | | origin == 3 : 73
   | | | Model &gt;= 78 : 41            {2176.20 16.37 33.66}
   | | | | Model &gt;= 80 : 31          {2176.10 16.36 34.84} &lt;=== best
   | | | Model &lt;  78 : 32            {2155.03 16.41 26.87}
   | | origin != 3 : 135
   | | | origin == 2 : 63
   | | | | Model &gt;= 75 : 36          {2363.81 16.76 30.83}
   | | | | Model &lt;  75 : 27          {2284.96 16.67 26.30}
   | | | origin != 2 : 72
   | | | | Model &lt;  78 : 28          {2319.25 17.11 26.07}
   | | | | Model &gt;= 78 : 44          {2512.20 16.16 29.77}
   | | | | | Model &gt;= 80 : 31        {2547.77 16.51 30.00}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
XPLAIN=class<span class="hljs-string">&quot;XPLAIN&quot;</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">XPLAIN:new</span><span class="hljs-params">(top,egs)</span></span>
  <span class="hljs-keyword">local</span> i,stop,lefts,rights,yes, no
  egs  = egs <span class="hljs-keyword">or</span> top
  i    = new({egs=egs,top=top},XPLAIN)
  stop = (#top._all)^the.minItems 
  <span class="hljs-keyword">if</span> #egs._all &gt; <span class="hljs-number">2</span>*stop <span class="hljs-keyword">then</span>
    lefts, rights= top:half(egs._all)
    <span class="hljs-keyword">if</span> #lefts._all &lt; #egs._all <span class="hljs-keyword">then</span>
      i.bin   = BIN:best( lefts:bins(rights) ) 
      yes, no = top:copy(), top:copy()
      <span class="hljs-keyword">for</span> _,row <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(egs._all) <span class="hljs-keyword">do</span> 
        (i.bin:selects(row) <span class="hljs-keyword">and</span> yes <span class="hljs-keyword">or</span> no):add(row) <span class="hljs-keyword">end</span>
      <span class="hljs-keyword">if</span> #yes._all &gt; stop <span class="hljs-keyword">then</span> i.yes  = XPLAIN(top, yes) <span class="hljs-keyword">end</span>
      <span class="hljs-keyword">if</span> #no._all  &gt; stop <span class="hljs-keyword">then</span> i.no   = XPLAIN(top, no) <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">return</span> i <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">XPLAIN.show</span><span class="hljs-params">(i, pre,how)</span></span>
  pre, how = pre <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;&quot;</span>, how <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;&quot;</span>
  <span class="hljs-keyword">local</span> front = fmt(<span class="hljs-string">&quot;%s%s%s&quot;</span>, pre, how, #i.egs._all)
  <span class="hljs-keyword">if</span>   i.yes <span class="hljs-keyword">and</span> i.no 
  <span class="hljs-keyword">then</span> <span class="hljs-built_in">print</span>(fmt(<span class="hljs-string">&quot;%-40s&quot;</span>,front))
  <span class="hljs-keyword">else</span> <span class="hljs-built_in">print</span>(fmt(<span class="hljs-string">&quot;%-40s %s&quot;</span>,front, o(rnds(i.egs:mid()))))
  <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">if</span> i.yes <span class="hljs-keyword">then</span> i.yes:show(<span class="hljs-string">&quot;| &quot;</span>.. pre, i.bin:show()     ..<span class="hljs-string">&quot; : &quot;</span>) <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">if</span> i.no  <span class="hljs-keyword">then</span> i.no:show( <span class="hljs-string">&quot;| &quot;</span>.. pre, i.bin:show(<span class="hljs-literal">true</span>) ..<span class="hljs-string">&quot; : &quot;</span>) <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span>

<span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">optimize</span><span class="hljs-params">(egs,    cluster,leaves,row1,row2)</span></span>
  cluster = CLUSTER(egs) 
  <span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">order</span><span class="hljs-params">(a,b)</span></span> <span class="hljs-keyword">return</span> a.egs:betters(b.egs)  <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">for</span> rank,leaf <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(quicksort(cluster:leaves(), order)) <span class="hljs-keyword">do</span>
    leaf.rank = rank <span class="hljs-keyword">end</span>                     
  <span class="hljs-keyword">return</span> cluster <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CLUSTER.project</span><span class="hljs-params">(i,row)</span></span>
  <span class="hljs-keyword">return</span> cosine(i.top:dist(row, i.left), i.top:dist(row, i.right), i.c) <span class="hljs-keyword">end</span>
 
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CLUSTER.where</span><span class="hljs-params">(i,row)</span></span>
  <span class="hljs-keyword">if</span>   i:leaf() <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> i <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">if</span>   i:project(row) &lt;= i.border 
  <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> i.lefts  <span class="hljs-keyword">and</span> i.lefts:where( row) <span class="hljs-keyword">or</span> i
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> i.rights <span class="hljs-keyword">and</span> i.rights:where(row) <span class="hljs-keyword">or</span> i <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span> 

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CLUSTER.better</span><span class="hljs-params">(i,row1,row2,    where1, where2)</span></span>
  where1, where2 = i:where(row1), i:where(row2)
  <span class="hljs-keyword">if</span>     where1.rank &gt; where2.rank <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> 
  <span class="hljs-keyword">elseif</span> where1.rank &lt; where2.rank <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> 
  <span class="hljs-keyword">else</span>   <span class="hljs-keyword">return</span> where1:xbetter(row1,row2) <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CLUSTER.xbetter</span><span class="hljs-params">(i,row1,row2,  x1,x2)</span></span>
  x1,x2 = i:project(row1), i:project(row2)
  <span class="hljs-keyword">return</span> i.egs:better(i.left, i.right) <span class="hljs-keyword">and</span> x1 &lt;= x2 <span class="hljs-keyword">or</span> x1 &gt; x2 <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">CLUSTER.leaves</span><span class="hljs-params">(i, out)</span></span>
  out = out <span class="hljs-keyword">or</span> {}
  <span class="hljs-keyword">if</span> i:leaf() <span class="hljs-keyword">then</span> push(out,i) <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">if</span> i.lefts  <span class="hljs-keyword">then</span> i.lefts:leaves(out) <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">if</span> i.rights <span class="hljs-keyword">then</span> i.rights:leaves(out) <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">return</span> out
<span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">EGS.better</span><span class="hljs-params">(i,row1,row2)</span></span>
  <span class="hljs-keyword">local</span> s1, s2, n, a, b = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, #i.cols.y
  <span class="hljs-keyword">for</span> _,col <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(i.cols.y) <span class="hljs-keyword">do</span>
    a  = col:norm( row1[col.at] )
    b  = col:norm( row2[col.at] )
    s1 = s1 - <span class="hljs-number">2.7183</span>^(col.w * (a - b) / n)
    s2 = s2 - <span class="hljs-number">2.7183</span>^(col.w * (b - a) / n) <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">return</span>  s1 / n &lt; s2 / n  <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">EGS.betters</span><span class="hljs-params">(i,j)</span></span>
  <span class="hljs-keyword">return</span> i:better(i:mid(i.cols.all), j:mid(j.cols.all)) <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quintiles</span><span class="hljs-params">(ts,width,  nums,out,all,n,m)</span></span>
  width=width <span class="hljs-keyword">or</span> <span class="hljs-number">32</span>
  nums=NUM(); <span class="hljs-keyword">for</span> _,t <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(ts) <span class="hljs-keyword">do</span>
                <span class="hljs-keyword">for</span> _,x <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(<span class="hljs-built_in">sort</span>(t)) <span class="hljs-keyword">do</span> add(nums,x) <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span>
  all,out = nums.all, {}
  <span class="hljs-keyword">for</span> _,t <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(ts) <span class="hljs-keyword">do</span>
     <span class="hljs-keyword">local</span> s, where = {}
     where = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(n)</span></span> <span class="hljs-keyword">return</span> (width*nums:norm(n))//<span class="hljs-number">1</span> <span class="hljs-keyword">end</span>
     <span class="hljs-keyword">for</span> j = <span class="hljs-number">1</span>, width <span class="hljs-keyword">do</span> s[j]=<span class="hljs-string">&quot; &quot;</span> <span class="hljs-keyword">end</span>
     <span class="hljs-keyword">for</span> j = where(per(t,<span class="hljs-number">.1</span>)), where(per(t,<span class="hljs-number">.3</span>)) <span class="hljs-keyword">do</span> s[j]=<span class="hljs-string">&quot;-&quot;</span> <span class="hljs-keyword">end</span>
     <span class="hljs-keyword">for</span> j = where(per(t,<span class="hljs-number">.7</span>)), where(per(t,<span class="hljs-number">.9</span>)) <span class="hljs-keyword">do</span> s[j]=<span class="hljs-string">&quot;-&quot;</span> <span class="hljs-keyword">end</span>
     s[where(per(t, <span class="hljs-number">.5</span>))] = <span class="hljs-string">&quot;|&quot;</span>
     push(out,{display=<span class="hljs-built_in">table</span>.<span class="hljs-built_in">concat</span>(s),
               data = t,
               pers = map({<span class="hljs-number">.1</span>,<span class="hljs-number">.3</span>,<span class="hljs-number">.5</span>,<span class="hljs-number">.7</span>,<span class="hljs-number">.9</span>},
                           <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(p)</span></span> <span class="hljs-keyword">return</span> rnd(per(t,p))<span class="hljs-keyword">end</span>)}) <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">return</span> out <span class="hljs-keyword">end</span>
             
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">smallfx</span><span class="hljs-params">(xs,ys,     x,y,lt,gt,n)</span></span>
  lt,gt,n = <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>
  <span class="hljs-keyword">if</span> #ys &gt; #xs <span class="hljs-keyword">then</span> xs,ys=ys,xs <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">for</span> _,x <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(xs) <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">for</span> j=<span class="hljs-number">1</span>, <span class="hljs-built_in">math</span>.<span class="hljs-built_in">min</span>(<span class="hljs-number">64</span>,#ys) <span class="hljs-keyword">do</span>
      y = any(ys)
      <span class="hljs-keyword">if</span> y&lt;x <span class="hljs-keyword">then</span> lt=lt+<span class="hljs-number">1</span> <span class="hljs-keyword">end</span>
      <span class="hljs-keyword">if</span> y&gt;x <span class="hljs-keyword">then</span> gt=gt+<span class="hljs-number">1</span> <span class="hljs-keyword">end</span>
      n = n+<span class="hljs-number">1</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">math</span>.<span class="hljs-built_in">abs</span>(gt - lt) / n &lt;= the.cliffs <span class="hljs-keyword">end</span> 

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bootstrap</span><span class="hljs-params">(y0,z0)</span></span>
  <span class="hljs-keyword">local</span> x, y, z, b4, yhat, zhat, bigger, obs, adds
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">obs</span><span class="hljs-params">(a,b,    c)</span></span>
    c = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">abs</span>(a.mu - b.mu)
    <span class="hljs-keyword">return</span> (a.sd + b.sd) == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> c <span class="hljs-keyword">or</span> c/((x.sd^<span class="hljs-number">2</span>/x.n + y.sd^<span class="hljs-number">2</span>/y.n)^<span class="hljs-number">.5</span>) <span class="hljs-keyword">end</span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">adds</span><span class="hljs-params">(t, num)</span></span> 
    num = num <span class="hljs-keyword">or</span> NUM(); map(t, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span></span> add(num,x) <span class="hljs-keyword">end</span>); <span class="hljs-keyword">return</span> num <span class="hljs-keyword">end</span>
  y,z    = adds(y0), adds(z0)
  x      = adds(y0, adds(z0))
  b4     = obs(y,z)
  yhat   = map(y._all, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(y1)</span></span> <span class="hljs-keyword">return</span> y1 - y.mu + x.mu <span class="hljs-keyword">end</span>)
  zhat   = map(z._all, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(z1)</span></span> <span class="hljs-keyword">return</span> z1 - z.mu + x.mu <span class="hljs-keyword">end</span>)
  bigger = <span class="hljs-number">0</span>
  <span class="hljs-keyword">for</span> j=<span class="hljs-number">1</span>,the.boot <span class="hljs-keyword">do</span> 
    <span class="hljs-keyword">if</span> obs( adds(many(yhat,#yhat)),  adds(many(zhat,#zhat))) &gt; b4 
    <span class="hljs-keyword">then</span> bigger = bigger + <span class="hljs-number">1</span>/the.boot <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">return</span> bigger &gt;= the.conf <span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="sswrap ">
                <a class="ss" href="#section-6">&#x00a7;</a>
              </div>
              <p>XXX implement same
XXX need tests for stats</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">scottKnot</span><span class="hljs-params">(nums,      all,cohen)</span></span>
  <span class="hljs-keyword">local</span> mid = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(z)</span></span> <span class="hljs-keyword">return</span> z.some:mid() 
  <span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">summary</span><span class="hljs-params">(i,j,    out)</span></span>
    out = copy( nums[i] )
    <span class="hljs-keyword">for</span> k = i+<span class="hljs-number">1</span>, j <span class="hljs-keyword">do</span> out = out:merge(nums[k]) <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> out 
  <span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">div</span><span class="hljs-params">(lo,hi,rank,b4,       cut,best,l,l1,r,r1,now)</span></span>
    best = <span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> j = lo,hi <span class="hljs-keyword">do</span>
      <span class="hljs-keyword">if</span> j &lt; hi  <span class="hljs-keyword">then</span>
        l   = summary(lo,  j)
        r   = summary(j+<span class="hljs-number">1</span>, hi)
        now = (l.n*(mid(l) - mid(b4))^<span class="hljs-number">2</span> + r.n*(mid(r) - mid(b4))^<span class="hljs-number">2</span>
              ) / (l.n + r.n)
        <span class="hljs-keyword">if</span> now &gt; best <span class="hljs-keyword">then</span>
          <span class="hljs-keyword">if</span> <span class="hljs-built_in">math</span>.<span class="hljs-built_in">abs</span>(mid(l) - mid(r)) &gt;= cohen <span class="hljs-keyword">then</span>
            cut, best, l1, r1 = j, now, copy(l), copy(r) 
    <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">if</span> cut <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> l1:same(r1,the) <span class="hljs-keyword">then</span>
      rank = div(lo,    cut, rank, l1) + <span class="hljs-number">1</span>
      rank = div(cut+<span class="hljs-number">1</span>, hi,  rank, r1) 
    <span class="hljs-keyword">else</span>
      <span class="hljs-keyword">for</span> i = lo,hi <span class="hljs-keyword">do</span> nums[i].rank = rank <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> rank 
  <span class="hljs-built_in">table</span>.<span class="hljs-built_in">sort</span>(nums, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x,y)</span></span> <span class="hljs-keyword">return</span> mid(x) &lt; mid(y) <span class="hljs-keyword">end</span>)
  all   = summary(<span class="hljs-number">1</span>,#nums)
  cohen = all.sd * the.cohen
  div(<span class="hljs-number">1</span>, #nums, <span class="hljs-number">1</span>, all)
  <span class="hljs-keyword">return</span> nums <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GO.last</span><span class="hljs-params">()</span></span> 
  ok( <span class="hljs-number">30</span> == last{<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>}, <span class="hljs-string">&quot;lasts&quot;</span>) <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GO.per</span><span class="hljs-params">(  t)</span></span>
  t={};<span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">100</span> <span class="hljs-keyword">do</span> push(t,i*<span class="hljs-number">1000</span>) <span class="hljs-keyword">end</span>
  ok(<span class="hljs-number">70000</span> == per(t,<span class="hljs-number">.7</span>), <span class="hljs-string">&quot;per&quot;</span>) <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GO.many</span><span class="hljs-params">(  t)</span></span>
  t={};<span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">100</span> <span class="hljs-keyword">do</span> push(t,i) <span class="hljs-keyword">end</span>; many(t,<span class="hljs-number">10</span>) <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GO.sum</span><span class="hljs-params">(  t)</span></span> 
  t={};<span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">100</span> <span class="hljs-keyword">do</span> push(t,i) <span class="hljs-keyword">end</span>; ok(<span class="hljs-number">5050</span>==sum(t),<span class="hljs-string">&quot;sum&quot;</span>)<span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GO.shuffle</span><span class="hljs-params">( t, good)</span></span>
  t={<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>}
  good = <span class="hljs-literal">true</span>
  <span class="hljs-keyword">for</span> j=<span class="hljs-number">1</span>,<span class="hljs-number">10</span>^<span class="hljs-number">5</span> <span class="hljs-keyword">do</span> 
    t= shuffle(t); 
    good = good <span class="hljs-keyword">and</span> sum(t)==<span class="hljs-number">45</span>,<span class="hljs-string">&quot;shuffle &quot;</span>..j <span class="hljs-keyword">end</span> 
  ok(good, <span class="hljs-string">&quot;shuffling&quot;</span>) <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GO.sample</span><span class="hljs-params">(   m,n)</span></span>
  m,n = <span class="hljs-number">10</span>^<span class="hljs-number">5</span>,NUM(); <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,m <span class="hljs-keyword">do</span> n:add(i) <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">for</span> j=<span class="hljs-number">.1</span>,<span class="hljs-number">.9</span>,<span class="hljs-number">.1</span> <span class="hljs-keyword">do</span> 
    <span class="hljs-built_in">print</span>(j,per(n:all(),j),ish(per(n:all(),j),m*j,m*<span class="hljs-number">0.05</span>)) <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GO.sym</span><span class="hljs-params">(  s)</span></span>
  s=SYM(); map({<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>}, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span></span> s:add(x) <span class="hljs-keyword">end</span>)
  ok(ish(s:div(),<span class="hljs-number">1.378</span>, <span class="hljs-number">0.001</span>), <span class="hljs-string">&quot;ent&quot;</span>) <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GO.num</span><span class="hljs-params">( n)</span></span>
  n=NUM(); map({<span class="hljs-number">10</span>, <span class="hljs-number">12</span>, <span class="hljs-number">23</span>, <span class="hljs-number">23</span>, <span class="hljs-number">16</span>, <span class="hljs-number">23</span>, <span class="hljs-number">21</span>, <span class="hljs-number">16</span>}, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span></span> n:add(x) <span class="hljs-keyword">end</span>)
  <span class="hljs-built_in">print</span>(n:div())
  ok(ish(n:div(),<span class="hljs-number">5.2373</span>, <span class="hljs-number">.001</span>), <span class="hljs-string">&quot;div&quot;</span>) <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GO.nums</span><span class="hljs-params">( num,t,b4)</span></span>
  b4,t,num={},{},NUM()
  <span class="hljs-keyword">for</span> j=<span class="hljs-number">1</span>,<span class="hljs-number">1000</span> <span class="hljs-keyword">do</span> push(t,<span class="hljs-number">100</span>*r()*j) <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">for</span> j=<span class="hljs-number">1</span>,#t  <span class="hljs-keyword">do</span>  
    num:add(t[j])
    <span class="hljs-keyword">if</span> j%<span class="hljs-number">100</span>==<span class="hljs-number">0</span> <span class="hljs-keyword">then</span>    b4[j] =  fmt(<span class="hljs-string">&quot;%.5f&quot;</span>,num:div()) <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">for</span> j=#t,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span> <span class="hljs-keyword">do</span>  
    <span class="hljs-keyword">if</span> j%<span class="hljs-number">100</span>==<span class="hljs-number">0</span> <span class="hljs-keyword">then</span> ok(b4[j] == fmt(<span class="hljs-string">&quot;%.5f&quot;</span>,num:div()),<span class="hljs-string">&quot;div&quot;</span>..j) <span class="hljs-keyword">end</span>
    num:<span class="hljs-built_in">sub</span>(t[j]) <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GO.syms</span><span class="hljs-params">( t,b4,s,sym)</span></span>
  b4,t,sym, s={},{},SYM(), <span class="hljs-string">&quot;I have gone to seek a great perhaps.&quot;</span>
  t={}; <span class="hljs-keyword">for</span> j=<span class="hljs-number">1</span>,<span class="hljs-number">20</span> <span class="hljs-keyword">do</span> s:<span class="hljs-built_in">gsub</span>(<span class="hljs-string">&#x27;.&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span></span> t[#t+<span class="hljs-number">1</span>]=x <span class="hljs-keyword">end</span>) <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">for</span> j=<span class="hljs-number">1</span>,#t  <span class="hljs-keyword">do</span>  
    sym:add(t[j])
    <span class="hljs-keyword">if</span> j%<span class="hljs-number">100</span>==<span class="hljs-number">0</span> <span class="hljs-keyword">then</span>    b4[j] =  fmt(<span class="hljs-string">&quot;%.5f&quot;</span>,sym:div()) <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">for</span> j=#t,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span> <span class="hljs-keyword">do</span>  
    <span class="hljs-keyword">if</span> j%<span class="hljs-number">100</span>==<span class="hljs-number">0</span> <span class="hljs-keyword">then</span> ok(b4[j] == fmt(<span class="hljs-string">&quot;%.5f&quot;</span>,sym:div()),<span class="hljs-string">&quot;div&quot;</span>..j) <span class="hljs-keyword">end</span>
    sym:<span class="hljs-built_in">sub</span>(t[j]) <span class="hljs-keyword">end</span> 
  <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GO.loader</span><span class="hljs-params">(  num)</span></span>
  <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> things(the.file) <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">if</span> num <span class="hljs-keyword">then</span> num:add(row[<span class="hljs-number">1</span>]) <span class="hljs-keyword">else</span> num=NUM() <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span>
  ok(ish(num.mu, <span class="hljs-number">5.455</span>,<span class="hljs-number">0.001</span>),<span class="hljs-string">&quot;loadmu&quot;</span>)
  ok(ish(num.sd, <span class="hljs-number">1.701</span>,<span class="hljs-number">0.001</span>),<span class="hljs-string">&quot;loadsd&quot;</span>) <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GO.egsShow</span><span class="hljs-params">(  e)</span></span>
  ok(EGS{<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;Age&quot;</span>,<span class="hljs-string">&quot;Weigh-&quot;</span>},<span class="hljs-string">&quot;can make EGS?&quot;</span>) <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GO.egsHead</span><span class="hljs-params">( )</span></span> 
  ok(EGS({<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-string">&quot;Weight!&quot;</span>}).cols.x,<span class="hljs-string">&quot;EGS&quot;</span>)  <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GO.egs</span><span class="hljs-params">(   egs)</span></span>
  egs = EGS:new4file(the.file)
  ok(ish(egs.cols.x[<span class="hljs-number">1</span>].mu, <span class="hljs-number">5.455</span>,<span class="hljs-number">0.001</span>),<span class="hljs-string">&quot;loadmu&quot;</span>)
  ok(ish(egs.cols.x[<span class="hljs-number">1</span>].sd, <span class="hljs-number">1.701</span>,<span class="hljs-number">0.001</span>),<span class="hljs-string">&quot;loadsd&quot;</span>) <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GO.dist</span><span class="hljs-params">(  ds,egs,one,d1,d2,d3,r1,r2,r3)</span></span>
  egs = EGS:new4file(the.file)
  one = egs._all[<span class="hljs-number">1</span>]
  ds={};<span class="hljs-keyword">for</span> j=<span class="hljs-number">1</span>,<span class="hljs-number">20</span> <span class="hljs-keyword">do</span> 
         push(ds,egs:dist(any(egs._all), any(egs._all))) <span class="hljs-keyword">end</span>
  oo(rnds(<span class="hljs-built_in">sort</span>(ds),<span class="hljs-string">&quot;%5.3f&quot;</span>))
  <span class="hljs-keyword">for</span> j=<span class="hljs-number">1</span>,<span class="hljs-number">10</span> <span class="hljs-keyword">do</span>
    r1,r2,r3 = any(egs._all), any(egs._all), any(egs._all)
    d1=egs:dist(r1,r2)
    d2=egs:dist(r2,r3)
    d3=egs:dist(r1,r3)
    ok(d1&lt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> d2 &lt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> d3 &lt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> d1&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> d2&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span> d3&gt;=<span class="hljs-number">0</span> <span class="hljs-keyword">and</span>
       egs:dist(r1,r2) == egs:dist(r2,r1) <span class="hljs-keyword">and</span>
       egs:dist(r1,r1) == <span class="hljs-number">0</span>               <span class="hljs-keyword">and</span>
       d3 &lt;= d1+d2,                       <span class="hljs-string">&quot;dist&quot;</span>..j)  <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GO.half</span><span class="hljs-params">(  egs,lefts,rights)</span></span>
  egs = EGS:new4file(the.file)
  lefts, rights = egs:half()
  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;before:&quot;</span>, o(rnds(egs:mid())))
  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;half1:&quot;</span>,  o(rnds( lefts:mid())),  
                   egs:betters(lefts,egs) <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;better&quot;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;worse&quot;</span>) 
  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;half2:&quot;</span>,  o(rnds(rights:mid())),  
                   egs:betters(rights,egs) <span class="hljs-keyword">and</span> <span class="hljs-string">&quot;better&quot;</span> <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;worse&quot;</span>) <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GO.cluster</span><span class="hljs-params">()</span></span>
  CLUSTER(EGS:new4file(the.file)):show() <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GO.bins</span><span class="hljs-params">(    egs,rights,lefts,col2)</span></span>
  egs= EGS:new4file(the.file)
  lefts, rights = egs:half(egs._all) 
  <span class="hljs-keyword">local</span> b4
  <span class="hljs-keyword">for</span> _,bin <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(lefts:bins(rights)) <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">if</span> bin.col.name ~= b4 <span class="hljs-keyword">then</span> <span class="hljs-built_in">print</span><span class="hljs-string">&quot;&quot;</span> <span class="hljs-keyword">end</span>
    b4 = bin.col.name
    <span class="hljs-built_in">print</span>(bin:show(), bin.n, rnd(bin.div)) <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span> 

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GO.xplain</span><span class="hljs-params">()</span></span>
  XPLAIN(EGS:new4file(the.file)):show() <span class="hljs-keyword">end</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GO.optimize</span><span class="hljs-params">(     rows,header)</span></span>
  rows = {}
  <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> things(the.file) <span class="hljs-keyword">do</span> 
    <span class="hljs-keyword">if</span> header <span class="hljs-keyword">then</span> push(rows,row) <span class="hljs-keyword">else</span> header=row <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">for</span> j=<span class="hljs-number">1</span>,the.n1 <span class="hljs-keyword">do</span>
    <span class="hljs-built_in">io</span>.<span class="hljs-built_in">write</span><span class="hljs-string">&quot;. &quot;</span>
    rows = shuffle(rows)
    <span class="hljs-keyword">local</span> train = EGS(header)
    <span class="hljs-keyword">local</span> test  = EGS(header)
    <span class="hljs-keyword">for</span> j,row <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(rows) <span class="hljs-keyword">do</span>
      (j&lt; #rows/<span class="hljs-number">2</span> <span class="hljs-keyword">and</span> train <span class="hljs-keyword">or</span> test):add(row) <span class="hljs-keyword">end</span> 
    CLUSTER(train):leaves()
    <span class="hljs-keyword">local</span> guesses = optimize(train)
    <span class="hljs-keyword">local</span> m,d=<span class="hljs-number">0</span>,<span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,the.n2 <span class="hljs-keyword">do</span>
       <span class="hljs-keyword">local</span> row1= any(test._all)
       <span class="hljs-keyword">local</span> row2= any(test._all)
       <span class="hljs-keyword">if</span> r()&gt; <span class="hljs-number">0.5</span> ==guesses:better(row1,row2) <span class="hljs-keyword">then</span>
         d = d+<span class="hljs-number">1</span> <span class="hljs-keyword">end</span>
       <span class="hljs-keyword">if</span> test:better(row1,row2)==guesses:better(row1,row2) <span class="hljs-keyword">then</span>
         m =m + <span class="hljs-number">1</span>
       <span class="hljs-keyword">end</span> <span class="hljs-keyword">end</span>
    <span class="hljs-built_in">print</span>(m/the.n2, d/the.n2) <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>

the = settings(help)
GO.main(the.todo, the.seed)
<span class="hljs-built_in">os</span>.<span class="hljs-built_in">exit</span>(GO.fails)</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
