age of massh ups. long supply chains of code X depending on code y on code z.
changed the way we think about coding. MIT changed its first year subject to stop
looking deeping and instead went to mash up. we end up wu with nsrat's supply
chain exposures. or long build times. or siatuations where one peron pulling a 3 line package
can (at least, temporarily) break the internet.

been templted. in enironemtns that remward and promote impressive technical
accomplishmnet, the idea that pirrmive looking apps can be qucly wired together,
is certainly appelaing. and many start seeing that wiring together as itsself
a productiviity advantage and start processing scirting or meta-level
tools to sped up that wiing system (e.g. punlish compoentns as types that
now the types of their oo, offer a visual programming environemtn where anything
can be wited nto anything else via a GUI, provided the types being produced
by the upstream thing match the types required as input by the downstream thing.

but instead of wiring together large assemblies,s perhaps we need to be looking
for synthesis and simplification across our code base. another way to use a prior
code base is to treat it like the results of an experiment. that work found out
of ABCDEF.. that AB and DE was most useful. also, looking over AB and DE we can see
a way toregactor them both sich that we can do both, in  less code. "THe best answer
is the one that destroys the question" said Susan Sontag and perhaps she was writing.
Perhaps old code shuld be viewed as a corpse that we, as code scavnegers, pick over
looking for the tastiest morsels.

Just to be clear, constantly reviewing and refactoring old code into new, simpler,
systems is not recommended in hfast pasced environments when all that matters
is getting a product out the door in order to generate the cash flow that lets us
live another day. 
But there is some evidence that that approach has gone too far. model stores. awful
code, looking pretty.

So perhaps, sometimes, it is useful to sit back and calm down
and reflect to see what we've learned from the past to simplify the future.

For the reader who is feeling  calm and reflective today, we offer the following.

XX all the above could ahve been said many times since the dan of programm,ing. we have one new thing to
add:a repeated result about minimal models. momimal or not at all. manifold.

also, olicy fails. need simler ssystems. we doing things wrong. models tores..
____
examppes from my role model file
-----

but the best way. no best way. albert. but at least a quick way o(log(N)) initial ass uitable to define. refuce a larger slace to smaelr space of options.
or run as a postoorcessor to simplify some other more complex inference. or as inspiration for research "X works in shortr... soulf that work better if..." and then we cangt\and better shortr 2.0

also the code is offered, politely, as a suggestion that maybe it is not a good idea to hac together lots of existing code into a massive conglomieration.
suopply chain threats. comphrension. simplicity nderneatn


surprise: doco and tests take a large percent of the work

small support (see make file)

beware log(0) and hi==lo


surprises
- Col is a primary thing
- Data is a thing. cloning. reporting. clistering = make recursive tables

iit comes with maths (sampling). it comes with knowledge of humans (cognitive theory)
it comes wih v&v out ofthe box. it comes with explanaintion and oversight.

sampling: the larger the sample, the less we keep (reservoir)

1% rule

losts of little functions

type hints

literature programming
- self dcumenting code (make file help, code comment#1

+iterative diconphmzation: discretization, sctott-knot, decision tree
+
 self-documentating code:
- type hints
- help string
- make menus

 +
 +----
 +
 +creational patterns
 +singleton(s): the of pattern
 +prototype: clone
 +factory: dsl . headers
 +
 +
 +
 +----
 +
 +Structural patterns
 +These patterns explain how to assemble objects and classes into larger structures while keeping these structures flexible and efficient.
 +composition: ROWS: cols: num
 +             ROWS: ROW
 +
 +farcade: dsl for th headers
 +decorator: range is a decorator for SYM
 +----
 +
 +behavior:
 +These patterns are concerned with algorithms and the assignment of responsibilities between objects.
 +iterator (csv)  stragey command (goal)
 +visitor:: mid, div,bins



self-documentating code:

- Makefile
- sting text

have to get the 5 laws in here somehow

the important thing here is not the specific ai algorithms but the infrastructure around it. if we do word counts on this code base and count
how many line are specific to (e.g.)  knn or naive bayes etc , the interesting pattern is that most of the code
is NOT specific. that is this code is a worknecnhu of N lines of code within which it is fast to assemble a NB (10 lines) or a KNN (12 lines)
.

better yet, with when software contains many small utilities that share the same (much larger) underling infrastructure,
then it becomes easy to mix and match more; i.e. to combine parts of this and parts of that according to your whims
or the needs of the next problem.



Less is more

Made famous by the designer and architect Ludwig Mies van der Rohe,
the dictum, Less is More came to define the brave, utopian ideals
of modernist design and architecture. In fact the phrase originated
in Robert Browning's 1855 poem Andrea del Sarto.

https://www.poetryfoundation.org/poems/43745/andrea-del-sarto

Although the postmodernism movement of the Eighties and Nineties
aimed at redefining this notion (one of postmodernism's chief
chroniclers, architect Robert Venturi proclaimed 'Less is a bore' [https://www.archdaily.com/964625/what-is-postmodernism] ,
the original phrase is still used widely today, especially to chasten
artists and designers who may have got carried away with ideas of
their own brilliance.

----
static code analysis
formatting conventions
---
data independence

isepeateion mechaism and policy

encapsulation (infrmation hiding ; e.g. dont exprt help string)

technical debt. the set in the ego code. hard not too

less is more
- stop writing classes

- self docuenting code. documentaion is part of cde

rapid feedback
- making making
  https://m.facebook.com/nt/screen/?params=%7B%22note_id%22%3A347492333250958%7D&path=%2Fnotes%2Fnote%2F&_rdr
  https://www.youtube.com/watch?v=nIonZ6-4nuU
- tdd
  - refactoring, rule of three.
- tests different to code since most tests are
  platform specific and dont want to change the code code,
  just the platfrom specific bits
- GH workspaces; unix error conventions

version control

- OSS licenses
- code of conduct
- .gitignore
- standard directors etc docs src test

dialog independence

policy and mechanism 
  - regular expressions
  - doc string
  - data headers

factories (cols)

namespace

functionap programming
- iterators

poymorphism: 
  - delegastion
  - protocls e.g. mid, like,


linux kernel best pracrices
- short release cycles
  - how to make a really short feedback loop
  - link to TDD
- zero internal boundaries
  - everyone uses same tools, config files for those tools in repo
  - e.g. static code tools

--
y=f(x) what does different y,x mean

variance, entropy

ranges. erging

streaming

incremental

partial sample
  reserovour sampling

bottom up clustering


background ruler (geometry)
- stops errors in lower levels of clister

rows created once, shared in different tables.
- row becomes place to store staitics.

tables
  - summaries


stats
- effect size
- nootstreps 



